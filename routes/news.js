const express = require('express');
const router = express.Router();
const { checkRole, authenticateJWT } = require('../middleware/verfiytoken');
const News = require('../models/News');
const { isAutoGenerated } = require('../middleware/isAutoGenerated');
const path = require('path');
const multer = require('multer');
const my = require('mysql');
const {RowDataPacket} = require("mysql/lib/protocol/packets");
const {response, json} = require("express");
require('dotenv').config();

const host = process.env.DATENBANK_HOST;
const db = process.env.DATENBANK;
const user = process.env.DATENBANK_USER;
const pw = process.env.DATENBANK_PASS;


const db1 = my.createConnection(
    {
        host:process.env.DATENBANK_HOST,
        database: process.env.DATENBANK1,
        user: process.env.DATENBANK_USER,
        password: process.env.DATENBANK_PASS,
    }
);

const con = my.createConnection(
    {
        host: host,
        database: db,
        user: user,
        password: pw,
    }
);
con.connect(function (err) {
    if (err) throw err;
    console.log("Connected!");
});


// Middleware for handling image uploads
const newsImageStorage = multer.diskStorage({
    destination: path.join(__dirname, '../public/news_images'), // Use absolute path for the destination
    filename: function (req, file, cb) {
        cb(null, `${Date.now()}${path.extname(file.originalname)}`);
    },
});

const uploadNewsImage = multer({
    storage: newsImageStorage,
    fileFilter: function (req, file, cb) {
        checkFileType(file, cb);
    },
}).single('image');
router.get('/audio', (req, res) => {
    const userLatitude = parseFloat(req.query.userLatitude);
    const userLongitude = parseFloat(req.query.userLongitude);
    const title =req.query.titel;
    const description =req.query.beschreibung;
    const creator =req.query.ersteller;
    const radius = 5; // Radius in Kilometern
    console.log(userLongitude, userLatitude)
    db1.query('SELECT * FROM audio_files', (err, rows) => {
        if (err) {
            console.error(err.message);
            res.status(500).json({ error: "Serverfehler" });
            console.log(response);
            return;
        }

        const audioFilesInRadius = rows.filter(row => {
            const distance = calculateDistance(userLatitude, userLongitude, row.latitude, row.longitude);
            return distance <= radius;
        });
        res.json({audioFiles: audioFilesInRadius});
        console.log(audioFilesInRadius);
    });
});


// Funktion zur Berechnung der Entfernung (wie zuvor definiert)
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Erdradius in Kilometern
    const dLat = (lat2 - lat1) * (Math.PI / 180);
    const dLon = (lon2 - lon1) * (Math.PI / 180);
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;
    return distance;
}
/*
        ---------------------
        News
        ---------------------
 */
// Get all news
router.get('/news', async (req, res) => {
    try {
        const news = await News.find();
        res.json(news);
    } catch (err) {
        console.error('Error getting news:', err);
        res.status(500).json({ message: 'An error occurred while fetching news.' });
    }
});

router.get('/game', async (req, res) => {
    try {

        await con.query(
            'SELECT' +
            ' s.spiel_id,' +
            ' s.spiel_name,' +
            ' s.spiel_reals_date,' +
            ' s.spiel_preis,' +
            ' f.FS_alter,' +
            ' st.ST_anzahl,' +
            ' bp.PB_name,' +
            ' e.EN_name,' +
            ' g.GE_name,' +
            ' GROUP_CONCAT(k.KO_name) AS Plattformen' +
            ' FROM spiel s' +
            ' LEFT JOIN sterne st ON s.spiel_sterne= st.SID' +
            ' LEFT JOIN fsk f ON s.spiel_fsk = f.FID' +
            ' LEFT JOIN spiel_plattform sk ON s.spiel_id = sk.Spiel_ID' +
            ' LEFT JOIN konsole k ON sk.Konsole_Id = k.KID' +
            ' LEFT JOIN spiel_genere sg ON s.spiel_id = sg.SPID' +
            ' LEFT JOIN genere g ON sg.GID = g.GID' +
            ' LEFT JOIN spiel_publisher sp ON s.spiel_id = sp.SPID' +
            ' LEFT JOIN publisher bp ON sp.PID = bp.PID' +
            ' LEFT JOIN spiel_entwickler se ON s.spiel_id = se.SPID' +
            ' LEFT JOIN entwickler e ON se.EID = e.EID' +
            ' GROUP BY s.spiel_id, s.spiel_name, s.spiel_reals_date, s.spiel_preis, f.FS_alter, st.ST_anzahl, bp.PB_name, e.EN_name, g.GE_name',
            async (err, rows) => {
                if (err) {
                    console.error(err);
                    return;
                }

                let result = Object.values(JSON.parse(JSON.stringify(rows)));
                console.log(result);
                res.status(200).json(result);
            }
        );
    } catch (err) {
        console.error('Error creating news:', err);
        res.status(500).json({ message: 'An error occurred while creating the news.' });
    }
});


// Create news
router.post('/news', async (req, res) => {
    // The checkRole middleware will allow only 'admin' or 'team' roles to proceed with creating news
    console.log("newss kann erstellt werden");
    uploadNewsImage(req, res, async function (err) {
        if (err) {
            return res.status(400).json({ message: err });
        }

         const  { tag, title, content  } =await req.body;
         const imageUrl =await req.file ? `/news_images/${req.file.filename}` : '';

         try{
            // Generate auto-generated tag based on the title


            // Get the name of the user who created the news
            const userName =await req.userId; // Assuming the user object has a "name" property

            const news = await News({
                title,
                date: new Date(),
                content,
                imageUrl,
                createdBy: userName,
            });

            await news.save();

            res.json({ message: 'News created successfully', news });
        } catch (err) {
            console.error('Error creating news:', err);
            res.status(500).json({ message: 'An error occurred while creating the news.' });
        }
    });
});


// Edit news
router.put('/news/:id', async (req, res) => {
    // The checkRole middleware will allow only 'admin' or 'team' roles to proceed with editing news

    const { id } = req.params;
    const { tag, title, content } = req.body;

    uploadNewsImage(req, res, async function (err) {
        if (err) {
            return res.status(400).json({ message: err });
        }

        try {
            const news = await News.findById(id);
            if (!news) {
                return res.status(404).json({ message: 'News not found' });
            }

            // Check if the news was auto-generated based on the title
            if (isAutoGenerated(news.title)) {
                return res.status(403).json({ message: 'Auto-generated news cannot be edited' });
            }

            // Remove the old image from the server if a new image is uploaded
            if (req.file && news.imageUrl) {
                fs.unlinkSync(`../public${news.imageUrl}`);
            }

            // Update the news properties
            news.tag = tag;
            news.title = title;
            news.content = content;
            news.imageUrl = req.file ? `/news_images/${req.file.filename}` : news.imageUrl; // Use the new image URL if uploaded, otherwise keep the old one
            await news.save();

            res.json({ message: 'News updated successfully', news });
        } catch (err) {
            console.error('Error updating news:', err);
            res.status(500).json({ message: 'An error occurred while updating the news.' });
        }
    });
});

// Delete news
router.delete('/news/:id', async (req, res) => {
    // The checkRole middleware will allow only 'admin' or 'team' roles to proceed with deleting news

    const { id } = req.params;

    try {
        const news = await News.findById(id);
        if (!news) {
            return res.status(404).json({ message: 'News not found' });
        }

        // Check if the news was auto-generated based on the title
        if (isAutoGenerated(news.title)) {
            return res.status(403).json({ message: 'Auto-generated news cannot be deleted' });
        }

        // Remove the image from the server
       // if (news.imageUrl) {
       //    fs.unlinkSync(`../public${news.imageUrl}`);
       // }
        console.log("Nes wird jetezt geschlöscht")
        await news.deleteOne();

        console.log("New wurde geschlöscht")

        res.json({ message: 'News deleted successfully' });
    } catch (err) {
        console.error('Error deleting news:', err);
        res.status(500).json({ message: 'An error occurred while deleting the news.' });
    }
});


function checkFileType(file, cb) {
    const filetypes = /jpeg|jpg|png|gif/;
    const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = filetypes.test(file.mimetype);
    if (extname && mimetype) {
        return cb(null, true);
    } else {
        cb('Error: Images Only!');
    }
}

// Serve static files from the 'public' folder
router.use(express.static(path.join(__dirname, '../public/news_images')));
module.exports = router;
